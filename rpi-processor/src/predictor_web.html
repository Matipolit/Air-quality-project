<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Air Quality Predictor - Visual</title>
        <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family:
                    -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                    "Helvetica Neue", Arial, sans-serif;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                min-height: 100vh;
                padding: 20px;
                color: #333;
            }

            .container {
                max-width: 1400px;
                margin: 0 auto;
            }

            h1 {
                text-align: center;
                color: white;
                margin-bottom: 30px;
                font-size: 2.5em;
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
            }

            .card {
                background: white;
                border-radius: 12px;
                padding: 25px;
                margin-bottom: 20px;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            }

            .card h2 {
                margin-bottom: 20px;
                color: #667eea;
                border-bottom: 2px solid #667eea;
                padding-bottom: 10px;
            }

            .controls {
                display: flex;
                gap: 15px;
                align-items: center;
                flex-wrap: wrap;
                margin-bottom: 20px;
            }

            .controls button {
                padding: 10px 20px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                font-weight: 600;
                transition: all 0.3s;
            }

            .controls button:hover:not(:disabled) {
                transform: translateY(-2px);
                box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
            }

            .controls button:disabled {
                background: #ccc;
                cursor: not-allowed;
                transform: none;
            }

            .date-display {
                font-size: 1.1em;
                font-weight: 600;
                color: #667eea;
                flex-grow: 1;
                text-align: center;
            }

            .chart-container {
                position: relative;
                height: 400px;
                margin-bottom: 30px;
            }

            .help-text {
                background: #e7f3ff;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 20px;
                border-radius: 4px;
            }

            .help-text p {
                margin: 5px 0;
                color: #555;
                line-height: 1.6;
            }

            .loading {
                text-align: center;
                color: #667eea;
                font-size: 18px;
                padding: 20px;
            }

            .error {
                background: #fee;
                border: 2px solid #fcc;
                color: #c33;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }

            .prediction-panel {
                display: none;
                margin-top: 20px;
            }

            .prediction-panel.active {
                display: block;
            }

            .metric-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                gap: 20px;
                margin-top: 20px;
            }

            .metric-card {
                background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
                padding: 20px;
                border-radius: 8px;
            }

            .metric-card h3 {
                color: #667eea;
                margin-bottom: 15px;
                font-size: 1.2em;
                text-align: center;
            }

            .metric-row {
                display: flex;
                justify-content: space-between;
                padding: 8px 0;
                border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            }

            .metric-row:last-child {
                border-bottom: none;
            }

            .metric-label {
                color: #666;
                font-size: 0.9em;
            }

            .metric-value {
                font-weight: bold;
                color: #333;
            }

            .metric-value.current {
                color: #3498db;
            }

            .metric-value.predicted {
                color: #667eea;
            }

            .metric-value.actual {
                color: #27ae60;
            }

            .metric-value.error-positive {
                color: #e74c3c;
            }

            .metric-value.error-negative {
                color: #27ae60;
            }

            .spinner {
                border: 4px solid #f3f3f3;
                border-top: 4px solid #667eea;
                border-radius: 50%;
                width: 40px;
                height: 40px;
                animation: spin 1s linear infinite;
                margin: 20px auto;
            }

            @keyframes spin {
                0% {
                    transform: rotate(0deg);
                }
                100% {
                    transform: rotate(360deg);
                }
            }

            .selected-point-info {
                background: #fff3cd;
                border: 2px solid #ffc107;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 15px;
            }

            .selected-point-info p {
                margin: 5px 0;
                color: #856404;
            }

            .tab-buttons {
                display: flex;
                gap: 10px;
                margin-bottom: 20px;
            }

            .tab-button {
                padding: 10px 20px;
                background: #f0f0f0;
                border: 2px solid #ddd;
                border-radius: 8px;
                cursor: pointer;
                font-weight: 600;
                transition: all 0.3s;
            }

            .tab-button.active {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                border-color: #667eea;
            }

            @media (max-width: 768px) {
                h1 {
                    font-size: 1.8em;
                }

                .controls {
                    flex-direction: column;
                }

                .chart-container {
                    height: 300px;
                }
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>üå°Ô∏è Air Quality Predictor - Interactive</h1>

            <div class="card">
                <h2>Instructions</h2>
                <div class="help-text">
                    <p>
                        <strong>How to use:</strong> Click on any point in the
                        charts below to make a prediction. The system will use
                        data from the 3 hours before the selected point to
                        predict conditions 1 hour into the future.
                    </p>
                    <p>
                        Use the navigation buttons to move through different
                        days of data. If actual data exists for the predicted
                        time, you'll see a comparison with error metrics.
                    </p>
                </div>
            </div>

            <div class="card">
                <div class="controls">
                    <button onclick="previousDay()" id="prev-btn">
                        ‚Üê Previous Day
                    </button>
                    <div class="date-display" id="current-date">Loading...</div>
                    <button onclick="nextDay()" id="next-btn">
                        Next Day ‚Üí
                    </button>
                    <button onclick="loadInitialData()" id="refresh-btn">
                        üîÑ Refresh
                    </button>
                </div>

                <div class="tab-buttons">
                    <button
                        class="tab-button active"
                        onclick="switchMetric('co2')"
                        id="tab-co2"
                    >
                        CO‚ÇÇ
                    </button>
                    <button
                        class="tab-button"
                        onclick="switchMetric('temperature')"
                        id="tab-temperature"
                    >
                        Temperature
                    </button>
                    <button
                        class="tab-button"
                        onclick="switchMetric('humidity')"
                        id="tab-humidity"
                    >
                        Humidity
                    </button>
                </div>

                <div class="chart-container">
                    <canvas id="dataChart"></canvas>
                </div>

                <div id="loading-indicator" style="display: none">
                    <div class="spinner"></div>
                    <p class="loading">Loading data...</p>
                </div>

                <div id="error-container"></div>

                <div id="prediction-panel" class="prediction-panel">
                    <h2>Prediction Results</h2>

                    <div id="selected-point-info"></div>

                    <div class="metric-grid" id="prediction-results"></div>
                </div>
            </div>
        </div>

        <script>
            let currentDate = null;
            let allData = [];
            let chart = null;
            let currentMetric = "co2";
            let selectedPoint = null;
            let predictionData = null;

            // Initialize
            window.addEventListener("DOMContentLoaded", async () => {
                await loadInitialData();
            });

            async function loadInitialData() {
                try {
                    showLoading(true);
                    hideError();

                    // Get the most recent data point to determine starting date
                    const response = await fetch(
                        "__API_BASE_PATH__/api/available-timestamps",
                    );
                    if (!response.ok) {
                        throw new Error("Failed to load timestamps");
                    }

                    const timestamps = await response.json();
                    if (timestamps.length === 0) {
                        showError("No data available in the database");
                        showLoading(false);
                        return;
                    }

                    // Use the most recent timestamp
                    const mostRecent = new Date(timestamps[0].time);
                    currentDate = new Date(mostRecent);
                    currentDate.setHours(0, 0, 0, 0);

                    await loadDayData();
                } catch (error) {
                    console.error("Error loading initial data:", error);
                    showError("Failed to load initial data: " + error.message);
                } finally {
                    showLoading(false);
                }
            }

            async function loadDayData() {
                try {
                    showLoading(true);
                    hideError();

                    const startDate = new Date(currentDate);
                    const endDate = new Date(currentDate);
                    endDate.setDate(endDate.getDate() + 1);

                    const response = await fetch(
                        "__API_BASE_PATH__/api/data-range",
                        {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                            },
                            body: JSON.stringify({
                                start_date: startDate.toISOString(),
                                end_date: endDate.toISOString(),
                            }),
                        },
                    );

                    if (!response.ok) {
                        throw new Error("Failed to load data for date range");
                    }

                    allData = await response.json();

                    if (allData.length === 0) {
                        showError(
                            "No data available for " +
                                currentDate.toLocaleDateString(),
                        );
                    }

                    updateDateDisplay();
                    updateChart();
                    clearPrediction();
                } catch (error) {
                    console.error("Error loading day data:", error);
                    showError("Failed to load data: " + error.message);
                } finally {
                    showLoading(false);
                }
            }

            function updateDateDisplay() {
                const dateStr = currentDate.toLocaleDateString("en-US", {
                    weekday: "long",
                    year: "numeric",
                    month: "long",
                    day: "numeric",
                    timeZone: "UTC",
                });
                document.getElementById("current-date").textContent =
                    dateStr + " (UTC)";
            }

            function updateChart() {
                const ctx = document.getElementById("dataChart");

                const datasets = [];
                const metricConfig = {
                    co2: {
                        label: "CO‚ÇÇ (ppm)",
                        color: "rgb(255, 99, 132)",
                        yAxisLabel: "CO‚ÇÇ (ppm)",
                    },
                    temperature: {
                        label: "Temperature (¬∞C)",
                        color: "rgb(255, 159, 64)",
                        yAxisLabel: "Temperature (¬∞C)",
                    },
                    humidity: {
                        label: "Humidity (%)",
                        color: "rgb(54, 162, 235)",
                        yAxisLabel: "Humidity (%)",
                    },
                };

                const config = metricConfig[currentMetric];
                const data = allData.map((d) => ({
                    x: new Date(d.time),
                    y: d[currentMetric],
                }));

                datasets.push({
                    label: config.label,
                    data: data,
                    borderColor: config.color,
                    backgroundColor: config.color.replace(")", ", 0.1)"),
                    borderWidth: 2,
                    pointRadius: 3,
                    pointHoverRadius: 6,
                    tension: 0.1,
                });

                // Add prediction point if exists
                if (predictionData && selectedPoint) {
                    // Add a connecting line from selected to predicted point
                    datasets.push({
                        label: "Prediction Path",
                        data: [
                            {
                                x: new Date(selectedPoint.time),
                                y: selectedPoint[currentMetric],
                            },
                            {
                                x: new Date(predictionData.prediction_time),
                                y: predictionData.predicted[currentMetric],
                            },
                        ],
                        borderColor: "rgba(147, 51, 234, 0.5)",
                        backgroundColor: "transparent",
                        borderWidth: 2,
                        borderDash: [5, 5],
                        pointRadius: 0,
                        showLine: true,
                        tension: 0,
                    });

                    datasets.push({
                        label: "Selected Point",
                        data: [
                            {
                                x: new Date(selectedPoint.time),
                                y: selectedPoint[currentMetric],
                            },
                        ],
                        borderColor: "rgb(102, 126, 234)",
                        backgroundColor: "rgb(102, 126, 234)",
                        pointRadius: 8,
                        pointHoverRadius: 10,
                        showLine: false,
                    });

                    datasets.push({
                        label: "Predicted Point",
                        data: [
                            {
                                x: new Date(predictionData.prediction_time),
                                y: predictionData.predicted[currentMetric],
                            },
                        ],
                        borderColor: "rgb(147, 51, 234)",
                        backgroundColor: "rgb(147, 51, 234)",
                        pointRadius: 8,
                        pointHoverRadius: 10,
                        showLine: false,
                    });

                    if (predictionData.actual) {
                        datasets.push({
                            label: "Actual Point",
                            data: [
                                {
                                    x: new Date(predictionData.prediction_time),
                                    y: predictionData.actual[currentMetric],
                                },
                            ],
                            borderColor: "rgb(34, 197, 94)",
                            backgroundColor: "rgb(34, 197, 94)",
                            pointRadius: 8,
                            pointHoverRadius: 10,
                            showLine: false,
                        });
                    }
                }

                if (chart) {
                    chart.destroy();
                }

                chart = new Chart(ctx, {
                    type: "line",
                    data: { datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: "nearest",
                            axis: "x",
                            intersect: false,
                        },
                        onClick: handleChartClick,
                        plugins: {
                            legend: {
                                display: true,
                                position: "top",
                            },
                            tooltip: {
                                callbacks: {
                                    title: function (context) {
                                        if (context[0]) {
                                            const date = new Date(
                                                context[0].parsed.x,
                                            );
                                            return (
                                                date
                                                    .toISOString()
                                                    .replace("T", " ")
                                                    .substring(0, 19) + " UTC"
                                            );
                                        }
                                        return "";
                                    },
                                    label: function (context) {
                                        return (
                                            context.dataset.label +
                                            ": " +
                                            context.parsed.y.toFixed(2)
                                        );
                                    },
                                },
                            },
                        },
                        scales: {
                            x: {
                                type: "time",
                                time: {
                                    unit: "hour",
                                    displayFormats: {
                                        hour: "HH:mm",
                                    },
                                    timezone: "UTC",
                                },
                                title: {
                                    display: true,
                                    text: "Time (UTC)",
                                },
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: config.yAxisLabel,
                                },
                            },
                        },
                    },
                });
            }

            async function handleChartClick(event) {
                const points = chart.getElementsAtEventForMode(
                    event,
                    "nearest",
                    { intersect: false },
                    false,
                );

                if (points.length > 0) {
                    const firstPoint = points[0];
                    if (
                        firstPoint.datasetIndex === 0 &&
                        allData[firstPoint.index]
                    ) {
                        const clickedData = allData[firstPoint.index];
                        await makePrediction(clickedData);
                    }
                }
            }

            async function makePrediction(dataPoint) {
                try {
                    selectedPoint = dataPoint;
                    showLoading(true);
                    hideError();

                    const response = await fetch(
                        "__API_BASE_PATH__/api/predict",
                        {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                            },
                            body: JSON.stringify({
                                timestamp: dataPoint.time,
                            }),
                        },
                    );

                    if (!response.ok) {
                        throw new Error("Prediction request failed");
                    }

                    const result = await response.json();

                    console.log("Prediction result:", result);
                    console.log("Input time:", result.input_time);
                    console.log("Prediction time:", result.prediction_time);
                    console.log(
                        "Time difference (hours):",
                        (new Date(result.prediction_time) -
                            new Date(result.input_time)) /
                            (1000 * 60 * 60),
                    );

                    if (result.success) {
                        predictionData = result;
                        displayPrediction(result);
                        updateChart();
                    } else {
                        showError(
                            result.error || "Prediction failed for this point",
                        );
                        clearPrediction();
                    }
                } catch (error) {
                    console.error("Error making prediction:", error);
                    showError("Failed to make prediction: " + error.message);
                    clearPrediction();
                } finally {
                    showLoading(false);
                }
            }

            function displayPrediction(result) {
                const panel = document.getElementById("prediction-panel");
                const info = document.getElementById("selected-point-info");
                const results = document.getElementById("prediction-results");

                const inputTime = new Date(result.input_time);
                const predictionTime = new Date(result.prediction_time);

                info.innerHTML = `
                    <div class="selected-point-info">
                        <p><strong>Selected Time (UTC):</strong> ${inputTime.toISOString().replace("T", " ").substring(0, 19)}</p>
                        <p><strong>Prediction Time (UTC):</strong> ${predictionTime.toISOString().replace("T", " ").substring(0, 19)} (+1 hour)</p>
                    </div>
                `;

                results.innerHTML = `
                    ${createMetricCard("CO‚ÇÇ", "co2", result, "ppm")}
                    ${createMetricCard("Temperature", "temperature", result, "¬∞C")}
                    ${createMetricCard("Humidity", "humidity", result, "%")}
                `;

                panel.classList.add("active");
            }

            function createMetricCard(name, key, result, unit) {
                const current = result.input[key];
                const predicted = result.predicted[key];
                const actual = result.actual ? result.actual[key] : null;
                const diff = result.actual
                    ? result.actual[key + "_diff"]
                    : null;

                let actualRow = "";
                let errorRow = "";

                if (actual !== null) {
                    const errorClass =
                        Math.abs(diff) < 0.01
                            ? ""
                            : diff > 0
                              ? "error-positive"
                              : "error-negative";
                    const diffSign = diff > 0 ? "+" : "";

                    actualRow = `
                        <div class="metric-row">
                            <span class="metric-label">Actual:</span>
                            <span class="metric-value actual">${actual.toFixed(2)} ${unit}</span>
                        </div>
                    `;

                    errorRow = `
                        <div class="metric-row">
                            <span class="metric-label">Error:</span>
                            <span class="metric-value ${errorClass}">${diffSign}${diff.toFixed(2)} ${unit}</span>
                        </div>
                    `;
                }

                return `
                    <div class="metric-card">
                        <h3>${name}</h3>
                        <div class="metric-row">
                            <span class="metric-label">Current:</span>
                            <span class="metric-value current">${current.toFixed(2)} ${unit}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Predicted (+1h):</span>
                            <span class="metric-value predicted">${predicted.toFixed(2)} ${unit}</span>
                        </div>
                        ${actualRow}
                        ${errorRow}
                    </div>
                `;
            }

            function clearPrediction() {
                selectedPoint = null;
                predictionData = null;
                document
                    .getElementById("prediction-panel")
                    .classList.remove("active");
            }

            function switchMetric(metric) {
                currentMetric = metric;

                // Update tab buttons
                document.querySelectorAll(".tab-button").forEach((btn) => {
                    btn.classList.remove("active");
                });
                document
                    .getElementById("tab-" + metric)
                    .classList.add("active");

                updateChart();
            }

            async function previousDay() {
                currentDate.setDate(currentDate.getDate() - 1);
                await loadDayData();
            }

            async function nextDay() {
                currentDate.setDate(currentDate.getDate() + 1);
                await loadDayData();
            }

            function showLoading(show) {
                document.getElementById("loading-indicator").style.display =
                    show ? "block" : "none";
            }

            function showError(message) {
                const container = document.getElementById("error-container");
                container.innerHTML = `
                    <div class="error">
                        <strong>Error:</strong> ${message}
                    </div>
                `;
            }

            function hideError() {
                document.getElementById("error-container").innerHTML = "";
            }
        </script>
    </body>
</html>
